
1,iOS æ¨é€é€šçŸ¥
	//å¦‚æœç”¨æˆ·å…³é—­äº†æ¥æ”¶é€šçŸ¥åŠŸèƒ½ï¼Œè¯¥æ–¹æ³•å¯ä»¥è·³è½¬åˆ°APPè®¾ç½®é¡µé¢è¿›è¡Œä¿®æ”¹
	- (void)GoToAppSystemSetting {
	    dispatch_async(dispatch_get_main_queue(), ^{
	        UIApplication *application = [UIApplication sharedApplication];
	        NSURL *url = [NSURL URLWithString:UIApplicationOpenSettingsURLString];
	        if ([application canOpenURL:url]) {
	            if (@available(iOS 10.0, *)) {
	                if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {
	                    [application openURL:url options:@{} completionHandler:nil];
	                }
	            }else {
	                [application openURL:url];
	            }
	        }
	    });
	}

	//åˆ¤æ–­ç”¨æˆ·æ˜¯å¦å…è®¸æ¥æ”¶é€šçŸ¥
	- (void)CheckUserNotificationEnable{ 
	    if (@available(iOS 10.0, *)) {
	        UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
	        [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {
	            if (settings.notificationCenterSetting == UNNotificationSettingEnabled) {
	                NSLog(@"æ‰“å¼€äº†é€šçŸ¥");
	                if ([PlatformSDKManager Instance].sdkHandler.CustomEvent)
	                {
	                    [PlatformSDKManager Instance].sdkHandler.CustomEvent("Callback_CheckNotifyEnable:true");
	                }
	            }else {
	                NSLog(@"å…³é—­äº†é€šçŸ¥");
	                dispatch_sync(dispatch_get_main_queue(), ^{
	                    //åˆ·æ–°UIçš„ä»£ç æ”¾åˆ°ä¸»çº¿ç¨‹æ‰§è¡Œ
	                    [self handleTips];
	                });
	            }
	        }];
	    }else {
	        if ([[UIApplication sharedApplication] currentUserNotificationSettings].types == UIUserNotificationTypeNone){
	            NSLog(@"å…³é—­äº†é€šçŸ¥");
	            dispatch_sync(dispatch_get_main_queue(), ^{
	                [self handleTips];
	            });
	        }else {
	            NSLog(@"æ‰“å¼€äº†é€šçŸ¥");
	        }
	    }
	}

2,iOS æ‰‹ç”µç­’å¼€å¯å’Œå…³é—­
	typedef NS_ENUM(NSInteger, AVCaptureTorchMode) {
	    AVCaptureTorchModeOff  = 0,
	    AVCaptureTorchModeOn   = 1,
	    AVCaptureTorchModeAuto = 2,
	} API_AVAILABLE(macos(10.7), ios(4.0)) __WATCHOS_PROHIBITED __TVOS_PROHIBITED;

	//å¼€å¯+å…³é—­ğŸ”¦
	-(void)FlashlightON{
	    AVCaptureDevice *device =[AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
	    //ä¿®æ”¹å‰å¿…é¡»å…ˆé”å®š
	    [device lockForConfiguration:nil];
	    //å¿…é¡»åˆ¤å®šæ˜¯å¦æœ‰é—ªå…‰ç¯ï¼Œå¦åˆ™å¦‚æœæ²¡æœ‰é—ªå…‰ç¯ä¼šå´©æºƒ
	    if([device hasFlash]) {
	        if(device.torchMode==AVCaptureFlashModeOff) {
	            device.torchMode=AVCaptureTorchModeOn;
	        }else if(device.torchMode==AVCaptureFlashModeOn) {
	            device.torchMode=AVCaptureTorchModeOff;
	        }
	    }
	    [device unlockForConfiguration];
	}

3,iOS åˆ†äº«åŠŸèƒ½
	-ï¼ˆvoidï¼‰shareToSocial{
		UIActivityViewController *activityVC = [[UIActivityViewController alloc]initWithActivityItems:@[@"å›¾ç‰‡UIImage",@"å†…å®¹NSString",@"åˆ†äº«é“¾æ¥NSURL"] applicationActivities:nil];
	    activityVC.definesPresentationContext = YES;
	    //ä¸å‡ºç°åœ¨æ´»åŠ¨é¡¹ç›®
	    //activityVC.excludedActivityTypes = @[UIActivityTypePrint, UIActivityTypeCopyToPasteboard,UIActivityTypeAssignToContact,UIActivityTypeSaveToCameraRoll];
	    [self presentViewController:activityVC animated:YES completion:nil];
	    //åˆ†äº«ä¹‹åçš„å›è°ƒ
	    __weak typeof(activityVC) weekActivity = activityVC;
	    activityVC.completionWithItemsHandler = ^(UIActivityType  _Nullable activityType, BOOL completed, NSArray * _Nullable returnedItems, NSError * _Nullable activityError) {
	        
	        if (completionBlock) {
	            completionBlock(completed, activityError);
	            
	            [weekActivity dismissViewControllerAnimated:YES completion:nil];
	        }
	        
	        if (completed) {
	            NSLog(@"completed");
	            //åˆ†äº« æˆåŠŸ
	        } else {
	            NSLog(@"å¤±è´¥");
	            //åˆ†äº« å–æ¶ˆ
	        }
	    };
	}

4,æˆªå±åŠŸèƒ½
	/// é«˜è´¨é‡æˆªå±
	#pragma mark - å¤„ç†æˆªå±
	- (UIImage *)handlerScreenshot {
	    UIWindow *window = [UIApplication sharedApplication].keyWindow;
	//    UIGraphicsBeginImageContext(window.frame.size); /// è¿™ä¸ªæ–¹å¼è·å–çš„å›¾ç‰‡æ¸…æ™°åº¦å¾ˆä½
	    UIGraphicsBeginImageContextWithOptions(window.bounds.size, YES, 0.0);
	    [window.layer renderInContext:UIGraphicsGetCurrentContext()];
	    UIImage *screenshot = UIGraphicsGetImageFromCurrentImageContext();
	    UIGraphicsEndImageContext();
	    return screenshot;
	}

5,å¼€å¯æ‰‹æœºæŒ¯åŠ¨ï¼š
	[[UIApplication sharedApplication] setApplicationSupportsShakeToEdit:NO];

6,ç›‘å¬æˆªå±å’Œå½•å±ï¼š
	-(void)viewDidLoad {
	    [super viewDidLoad];
	    self.view.backgroundColor =[UIColor whiteColor];
	    [self setSubView];
	    //å¢åŠ ç›‘å¬->ç›‘å¬æˆªå›¾äº‹ä»¶
	    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleTips) name:UIApplicationUserDidTakeScreenshotNotification object:nil];
	}

	//å½“ç”¨æˆ·æˆªå±äº† æ€ä¹ˆåŠ ç›®å‰æ¥è¯´ åªèƒ½è¿›è¡Œæç¤ºã€‚
	-(void)handleTips {
	    UIAlertController * alertVc =[UIAlertController alertControllerWithTitle:@"ä¿¡æ¯æç¤º" message:@"ä¸ºä¿è¯ç”¨æˆ·å,å¯†ç å®‰å…¨,è¯·ä¸è¦æˆªå±æˆ–å½•å±!" preferredStyle:UIAlertControllerStyleAlert];
	    UIAlertAction * knowAction =[UIAlertAction actionWithTitle:@"çŸ¥é“äº†" style:UIAlertActionStyleDefault handler:nil];
	    [alertVc addAction:knowAction];
	    [self presentViewController:alertVc animated:YES completion:nil];
	}

	-(void)dealloc {
	    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationUserDidTakeScreenshotNotification object:nil];
	}


	-(void)viewWillAppear:(BOOL)animated {
	    [super viewWillAppear:animated];
	    //ç›‘æµ‹å½“å‰è®¾å¤‡æ˜¯å¦å¤„äºå½•å±çŠ¶æ€
	    UIScreen * sc = [UIScreen mainScreen];
	    if (sc.isCaptured) {
	        NSLog(@"æ­£åœ¨å½•åˆ¶-----%d",sc.isCaptured);
	        [self handleTips];
	    }
	    //ios11ä¹‹åæ‰å¯ä»¥å½•å±
	    [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(handleTips) name:UIScreenCapturedDidChangeNotification  object:nil];
	}

	-(void)dealloc {
	       [[NSNotificationCenter defaultCenter] removeObserver:self name:UIScreenCapturedDidChangeNotification object:nil];
	}

7,iOS è·å–è®¾å¤‡åç§°ï¼š
	/// è·å–å½“å‰Appçš„åŸºæœ¬ä¿¡æ¯å­—å…¸
	NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];
	//appåç§°
	NSString *app_Name = [infoDictionary objectForKey:@"CFBundleDisplayName"];
	// appç‰ˆæœ¬
	NSString *app_Version = [infoDictionary objectForKey:@"CFBundleShortVersionString"];
	 // app buildç‰ˆæœ¬
	NSString *app_build = [infoDictionary objectForKey:@"CFBundleVersion"];
	//æ‰‹æœºåˆ«åï¼š ç”¨æˆ·å®šä¹‰çš„åç§°
	NSString* userPhoneName = [[UIDevice currentDevice] name];
	//è®¾å¤‡åç§°
	NSString* deviceName = [[UIDevice currentDevice] systemName];
	//æ‰‹æœºç³»ç»Ÿç‰ˆæœ¬
	NSString* phoneVersion = [[UIDevice currentDevice] systemVersion];
	//æ‰‹æœºå‹å·
	NSString* phoneModel = [[UIDevice currentDevice] model];
	//åœ°æ–¹å‹å·ï¼ˆå›½é™…åŒ–åŒºåŸŸåç§°ï¼‰
	NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel];

	#import <sys/utsname.h>
	+ (NSString *)getDeviceName {
		struct utsname systemInfo;
		uname(&systemInfo);
		NSString *deviceString = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];
		return deviceString;
	}
	
    //simulator
    if ([platform isEqualToString:@"i386"])          return @"Simulator";
    if ([platform isEqualToString:@"x86_64"])        return @"Simulator";
    
    //AirPods
    if ([platform isEqualToString:@"AirPods1,1"])    return @"AirPods";
    //Apple TV
    if ([platform isEqualToString:@"AppleTV2,1"])    return @"Apple TV (2nd generation)";
    if ([platform isEqualToString:@"AppleTV3,1"])    return @"Apple TV (3rd generation)";
    if ([platform isEqualToString:@"AppleTV3,2"])    return @"Apple TV (3rd generation)";
    if ([platform isEqualToString:@"AppleTV5,3"])    return @"Apple TV (4th generation)";
    if ([platform isEqualToString:@"AppleTV6,2"])    return @"Apple TV 4K";
    //Apple Watch
    if ([platform isEqualToString:@"Watch1,1"])    return @"Apple Watch (1st generation)";
    if ([platform isEqualToString:@"Watch1,2"])    return @"Apple Watch (1st generation)";
    if ([platform isEqualToString:@"Watch2,6"])    return @"Apple Watch Series 1";
    if ([platform isEqualToString:@"Watch2,7"])    return @"Apple Watch Series 1";
    if ([platform isEqualToString:@"Watch2,3"])    return @"Apple Watch Series 2";
    if ([platform isEqualToString:@"Watch2,4"])    return @"Apple Watch Series 2";
    if ([platform isEqualToString:@"Watch3,1"])    return @"Apple Watch Series 3";
    if ([platform isEqualToString:@"Watch3,2"])    return @"Apple Watch Series 3";
    if ([platform isEqualToString:@"Watch3,3"])    return @"Apple Watch Series 3";
    if ([platform isEqualToString:@"Watch3,4"])    return @"Apple Watch Series 3";
    //HomePod
    if ([platform isEqualToString:@"AudioAccessory1,1"])    return @"HomePod";
    //iPad
    if ([platform isEqualToString:@"iPad1,1"])    return @"iPad";
    if ([platform isEqualToString:@"iPad2,1"])    return @"iPad 2";
    if ([platform isEqualToString:@"iPad2,2"])    return @"iPad 2";
    if ([platform isEqualToString:@"iPad2,3"])    return @"iPad 2";
    if ([platform isEqualToString:@"iPad2,4"])    return @"iPad 2";
    if ([platform isEqualToString:@"iPad3,1"])    return @"iPad (3rd generation)";
    if ([platform isEqualToString:@"iPad3,2"])    return @"iPad (3rd generation)";
    if ([platform isEqualToString:@"iPad3,3"])    return @"iPad (3rd generation)";
    if ([platform isEqualToString:@"iPad3,4"])    return @"iPad (4th generation)";
    if ([platform isEqualToString:@"iPad3,5"])    return @"iPad (4th generation)";
    if ([platform isEqualToString:@"iPad3,6"])    return @"iPad (4th generation)";
    if ([platform isEqualToString:@"iPad4,1"])    return @"iPad Air";
    if ([platform isEqualToString:@"iPad4,2"])    return @"iPad Air";
    if ([platform isEqualToString:@"iPad4,3"])    return @"iPad Air";
    if ([platform isEqualToString:@"iPad5,3"])    return @"iPad Air 2";
    if ([platform isEqualToString:@"iPad5,4"])    return @"iPad Air 2";
    if ([platform isEqualToString:@"iPad6,7"])    return @"iPad Pro (12.9-inch)";
    if ([platform isEqualToString:@"iPad6,8"])    return @"iPad Pro (12.9-inch)";
    if ([platform isEqualToString:@"iPad6,3"])    return @"iPad Pro (9.7-inch)";
    if ([platform isEqualToString:@"iPad6,4"])    return @"iPad Pro (9.7-inch)";
    if ([platform isEqualToString:@"iPad6,11"])    return @"iPad (5th generation)";
    if ([platform isEqualToString:@"iPad6,12"])    return @"iPad (5th generation)";
    if ([platform isEqualToString:@"iPad7,1"])    return @"iPad Pro (12.9-inch, 2nd generation)";
    if ([platform isEqualToString:@"iPad7,2"])    return @"iPad Pro (12.9-inch, 2nd generation)";
    if ([platform isEqualToString:@"iPad7,3"])    return @"iPad Pro (10.5-inch)";
    if ([platform isEqualToString:@"iPad7,4"])    return @"iPad Pro (10.5-inch)";
    if ([platform isEqualToString:@"iPad7,5"])    return @"iPad (6th generation)";
    if ([platform isEqualToString:@"iPad7,6"])    return @"iPad (6th generation)";
    //iPad mini
    if ([platform isEqualToString:@"iPad2,5"])    return @"iPad mini";
    if ([platform isEqualToString:@"iPad2,6"])    return @"iPad mini";
    if ([platform isEqualToString:@"iPad2,7"])    return @"iPad mini";
    if ([platform isEqualToString:@"iPad4,4"])    return @"iPad mini 2";
    if ([platform isEqualToString:@"iPad4,5"])    return @"iPad mini 2";
    if ([platform isEqualToString:@"iPad4,6"])    return @"iPad mini 2";
    if ([platform isEqualToString:@"iPad4,7"])    return @"iPad mini 3";
    if ([platform isEqualToString:@"iPad4,8"])    return @"iPad mini 3";
    if ([platform isEqualToString:@"iPad4,9"])    return @"iPad mini 3";
    if ([platform isEqualToString:@"iPad5,1"])    return @"iPad mini 4";
    if ([platform isEqualToString:@"iPad5,2"])    return @"iPad mini 4";
    //iPhone
    if ([platform isEqualToString:@"iPhone1,1"])     return @"iPhone 1G";
    if ([platform isEqualToString:@"iPhone1,2"])     return @"iPhone 3G";
    if ([platform isEqualToString:@"iPhone2,1"])     return @"iPhone 3GS";
    if ([platform isEqualToString:@"iPhone3,1"])     return @"iPhone 4";
    if ([platform isEqualToString:@"iPhone3,2"])     return @"iPhone 4";
    if ([platform isEqualToString:@"iPhone4,1"])     return @"iPhone 4S";
    if ([platform isEqualToString:@"iPhone5,1"])     return @"iPhone 5";
    if ([platform isEqualToString:@"iPhone5,2"])     return @"iPhone 5";
    if ([platform isEqualToString:@"iPhone5,3"])     return @"iPhone 5C";
    if ([platform isEqualToString:@"iPhone5,4"])     return @"iPhone 5C";
    if ([platform isEqualToString:@"iPhone6,1"])     return @"iPhone 5S";
    if ([platform isEqualToString:@"iPhone6,2"])     return @"iPhone 5S";
    if ([platform isEqualToString:@"iPhone7,1"])     return @"iPhone 6 Plus";
    if ([platform isEqualToString:@"iPhone7,2"])     return @"iPhone 6";
    if ([platform isEqualToString:@"iPhone8,1"])     return @"iPhone 6s";
    if ([platform isEqualToString:@"iPhone8,2"])     return @"iPhone 6s Plus";
    if ([platform isEqualToString:@"iPhone8,4"])     return @"iPhone SE";
    if ([platform isEqualToString:@"iPhone9,1"])     return @"iPhone 7";
    if ([platform isEqualToString:@"iPhone9,3"])     return @"iPhone 7";
    if ([platform isEqualToString:@"iPhone9,2"])     return @"iPhone 7 Plus";
    if ([platform isEqualToString:@"iPhone9,4"])     return @"iPhone 7 Plus";
    if ([platform isEqualToString:@"iPhone10,1"])    return @"iPhone 8";
    if ([platform isEqualToString:@"iPhone10,4"])    return @"iPhone 8";
    if ([platform isEqualToString:@"iPhone10,2"])    return @"iPhone 8 Plus";
    if ([platform isEqualToString:@"iPhone10,5"])    return @"iPhone 8 Plus";
    if ([platform isEqualToString:@"iPhone10,3"])    return @"iPhone X";
    if ([platform isEqualToString:@"iPhone10,6"])    return @"iPhone X";
    if ([platform isEqualToString:@"iPhone11,8"])    return @"iPhone XR";
    if ([platform isEqualToString:@"iPhone11,2"])    return @"iPhone XS";
    if ([platform isEqualToString:@"iPhone11,4"])    return @"iPhone XS Max";
    if ([platform isEqualToString:@"iPhone11,6"])    return @"iPhone XS Max";
    //iPod touch
    if ([platform isEqualToString:@"iPod1,1"])    return @"iPod touch";
    if ([platform isEqualToString:@"iPod2,1"])    return @"iPod touch (2nd generation)";
    if ([platform isEqualToString:@"iPod3,1"])    return @"iPod touch (3rd generation)";
    if ([platform isEqualToString:@"iPod4,1"])    return @"iPod touch (4th generation)";
    if ([platform isEqualToString:@"iPod5,1"])    return @"iPod touch (5th generation)";
    if ([platform isEqualToString:@"iPod7,1"])    return @"iPod touch (6th generation)";

8,iOS æ¸…é™¤è§’æ ‡
 	[UIApplication sharedApplication].applicationIconBadgeNumber = -1;     

9,iOS æ‘‡ä¸€æ‘‡
	#import "SignBoardViewController.h"
	#import <AVFoundation/AVFoundation.h>
	#import <AudioToolbox/AudioToolbox.h>
	#import <CoreAudio/CoreAudioTypes.h>
	@interface SignBoardViewController ()
	{
	}
	@property (nonatomic,strong) AVAudioPlayer * audioPlayer;

	@end

	@implementation SignBoardViewController

	- (void)viewDidLoad {
	  [super viewDidLoad];
	  // Do any additional setup after loading the view.
	  //è®¾ç½®å¯¼èˆª
	  [self makeNav];
	}

	#pragma mark å®šåˆ¶Nav
	- (void)makeNav
	{
	  [self.navigationItem setTitle:@"æ¯æ—¥ç­¾åˆ°"];//æ”¹å†™title
	  //ä¿®æ”¹å¯¼èˆªæŒ‰é’®ï¼Œå¹¶ä¸”ä¿®æ”¹å“åº”æ–¹æ³•
	  self.leftButton.frame = CGRectMake(0, 0, 13, 20);
	  [self.leftButton setBackgroundImage:[UIImage imageNamed:@"NavBack"] forState:UIControlStateNormal];
	  self.leftButton.layer.cornerRadius = 0;
	  self.leftButton.layer.masksToBounds = NO;
	  self.leftButton.layer.borderColor = [UIColor clearColor].CGColor;

	  //æ·»åŠ ç‚¹å‡»æ–¹æ³•
	  [self.leftButton addTarget:self action:@selector(navLeftClick) forControlEvents:UIControlEventTouchUpInside];

	  //éšè— å³è¾¹æŒ‰é’®
	  self.rightButton.hidden= YES;
	}

	#pragma mark navå·¦è¾¹å¯¼èˆªæŒ‰é’®æ–¹æ³•é‡å†™,è¿”å›æŒ‰é’®
	- (void)navLeftClick
	{
	  [self dismissViewControllerAnimated:YES completion:^{
	    nil;
	  }];
	}

	#pragma mark -
	#pragma mark ç‚¹å‡»
	- (void)touchesBegan:(nonnull NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event

	{
	  NSLog(@"ç‚¹å‡»ï¼Œè§¦æ‘¸æ–¹æ³•ç­‰");
	  AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);

	}

	#pragma mark -
	#pragma mark æ‘‡åŠ¨å¼€å§‹
	- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event

	{

	  NSLog(@"begin motion");

	}

	#pragma mark -
	#pragma mark æ‘‡åŠ¨ç»“æŸ
	- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event
	{
	  NSLog(@"end motion");
	  if (motion ==UIEventSubtypeMotionShake )
	  {
	    //æ’­æ”¾éŸ³æ•ˆ
	    SystemSoundID  soundID; // shake_sound_male.mp3
	    NSString *path = [[NSBundle mainBundle ] pathForResource:@"shake_sound_male" ofType:@"mp3"];
	    AudioServicesCreateSystemSoundID((__bridge CFURLRef)[NSURL fileURLWithPath:path], &soundID);
	    AudioServicesPlaySystemSound (soundID);
	    //è®¾ç½®éœ‡åŠ¨
	    AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);
	  }

	}

	#pragma mark -
	#pragma mark æ‘‡åŠ¨å–æ¶ˆ
	- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event
	{

	}

	- (void)didReceiveMemoryWarning {
	  [super didReceiveMemoryWarning];
	  // Dispose of any resources that can be recreated.
	}

10,æ‘„åƒå¤´æ£€æµ‹
	// AVCaptureVideoDataOutputSampleBufferDelegateä»£ç†æ–¹æ³•
	// æ‘„åƒå¤´è¾“å‡ºçš„è§†é¢‘æµ
	- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection {
		// è·å–è§†é¢‘æµçš„ç›¸å…³å‚æ•°
		CFDictionaryRef metadataDict = CMCopyDictionaryOfAttachments(NULL,sampleBuffer, kCMAttachmentMode_ShouldPropagate);
		NSDictionary *metadata = [[NSMutableDictionary alloc] initWithDictionary:(__bridge NSDictionary*)metadataDict];
		CFRelease(metadataDict);

		"exifä¸­æœ‰ä¸ªbrightnesså‚æ•°å€¼"
		NSDictionary *exifMetadata = [metadata[(NSString *)kCGImagePropertyExifDictionary] mutableCopy];
		float brightnessValue = [exifMetadata[(NSString *)kCGImagePropertyExifBrightnessValue] floatValue];

		// åœ¨UIä¸Šæ˜¾ç¤º
		self.cameraBightnessLbl.text = [NSString stringWithFormat:@"%.2f",brightnessValue];
	}

11, è·ç¦»ä¼ æ„Ÿå™¨æ£€æµ‹

    1. è·ç¦»ä¼ æ„Ÿå™¨é»˜è®¤æ˜¯å…³é—­çš„ï¼Œéœ€æ‰‹åŠ¨å¼€å¯
       [UIDevice currentDevice].proximityMonitoringEnabled = YES/NO;

    2. ä¼ æ„Ÿå™¨å¼€å¯åï¼Œé€šè¿‡é€šçŸ¥ç›‘å¬æ˜¯å¦æœ‰ç‰©ä½“é è¿‘
        1. é€šçŸ¥åï¼šUIDeviceProximityStateDidChangeNotificationï¼›
        2. è¿”å›å¯¹è±¡ï¼šnotification.objectä¼šè¿”å›UIDeviceå¯¹è±¡ï¼›
        3. åˆ¤æ–­ï¼šUIDeviceå¯¹è±¡çš„proximityStateå±æ€§æŒ‡ç¤ºæ˜¯å¦é è¿‘ç”¨æˆ·ï¼ŒYES(é è¿‘)ï¼NO(ç¦»å¼€)
    3. ä»£ç 
        - (IBAction)proximitySwitch:(UISwitch *)sender {
            // ä¼ æ„Ÿå™¨çš„å¼€å¯ä¸å…³é—­
            [UIDevice currentDevice].proximityMonitoringEnabled = sender.on;    

            // å¯ç”¨æ€§æ£€æµ‹
            if (sender.on && ![UIDevice currentDevice].proximityMonitoringEnabled) {
                sender.on = NO;
                [self showWithTitle:@"è·ç¦»ä¼ æ„Ÿå™¨ä¸å¯ç”¨" message:nil];
                return;
            }

            // é€šçŸ¥ç›‘å¬çŠ¶æ€
            if (sender.on) {
                [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(proximityStateChange:) name:UIDeviceProximityStateDidChangeNotification object:nil
                 ];
            } else {
                [[NSNotificationCenter defaultCenter] removeObserver:self name:UIDeviceProximityStateDidChangeNotification object:nil];
            }
        }
        
        - (void)proximityStateChange:(NSNotification *)noti {
            UIDevice *device = noti.object;
            if ([device isKindOfClass:[UIDevice class]]) {
                // æ˜¯å¦æœ‰ç‰©ä½“é è¿‘
                NSLog(@"%@", (device.proximityState? @"ç‰©ä½“é è¿‘" : @"ç‰©ä½“ç¦»å¼€"));
            }
        }

12, è®¡æ­¥å™¨
	è®¡æ­¥å™¨èƒ½è·å–çš„æ•°æ®
	1. startDateï¼šå¼€å§‹æ—¶é—´æ®µ
	2. endDateï¼šç»“æŸæ—¶é—´æ®µ
	3. numberOfStepsï¼šæ­¥æ•°
	4. distanceï¼šè·ç¦»
	5. floorsAscendedï¼šçˆ¬æ¥¼æ•°
	6. floorsDescendedï¼šä¸‹æ¥¼æ•°
	7. ios9ä»¥åçš„ç³»ç»Ÿæ‰æœ‰
	1. currentPaceï¼šå½“å‰æ­¥é€Ÿ in seconds per meter
	2. currentCadenceï¼šå½“å‰æ­¥é¢‘ in steps per second
	8. ios10çš„
	1. averageActivePaceï¼šå¹³å‡æ´»è·ƒæ—¶é—´æ®µçš„æ­¥é€Ÿ
	ä½¿ç”¨
		"è¿åŠ¨ä¸å¥åº·"æƒé™è®¾ç½®
		1. ä½¿ç”¨è®¡æ­¥å™¨éœ€æ·»åŠ æƒé™NSMotionUsageDescriptionæè¿°
		2. ç¬¬ä¸€æ¬¡ä½¿ç”¨CMPedometerå¯¹è±¡çš„æ—¶å€™ç³»ç»Ÿè‡ªåŠ¨ä¼šå‘ç”¨æˆ·è¯·æ±‚"è¿åŠ¨ä¸å¥åº·"æˆæƒ
		3. æˆæƒåˆ¤æ–­ï¼š[CMSensorRecorder isAuthorizedForRecording];
		4. æ²¡æ‰¾åˆ°æˆæƒçš„æ–¹æ³•ï¼šä¸è¿‡ç”±äºç³»ç»Ÿä¼šè‡ªåŠ¨æˆæƒ(ç¬¬2æ¡)ï¼Œé€šè¿‡ä¸‹é¢çš„æ–¹æ³•ä¹Ÿå¯ä»¥è¾¾åˆ°æˆæƒçš„æ•ˆæœï¼Œ
		è¯¥æ–¹æ³•åœ¨è·å–åˆ°ç”¨æˆ·çš„é€‰æ‹©ä¹‹åæ‰ä¼šè¿›è¡Œå›è°ƒ
		[self.pedometer queryPedometerDataFromDate:toDate:withHandler:]

	è·å–æ•°æ®
		1. CMPedometerä¸­çš„å¯¹è±¡æ–¹æ³•
		// è·å–æŸæ—¶é—´æ®µçš„å†å²æ•°æ®
		- (void)queryPedometerDataFromDate:(NSDate *)start toDate:(NSDate *)end withHandler:(CMPedometerHandler)handler;
		// ä»æŸæ—¶é—´æ®µå¼€å§‹å®æ—¶è·å–æ•°æ®ï¼Œåœæ­¢è·å–çš„æ—¶å€™éœ€è°ƒç”¨stopPedometerUpdatesæ–¹æ³•
		- (void)startPedometerUpdatesFromDate:(NSDate *)start withHandler:(CMPedometerHandler)handler;
		// è·å–è®¡æ­¥å™¨çš„çŠ¶æ€ï¼ˆæš‚åœï¼è®°æ­¥ï¼‰ï¼Œåœæ­¢è·å–çš„æ—¶å€™éœ€è°ƒç”¨stopPedometerEventUpdatesæ–¹æ³•
		- (void)startPedometerEventUpdatesWithHandler:(CMPedometerEventHandler)handler NS_AVAILABLE(NA,10_0) __WATCHOS_AVAILABLE(3_0);
		// åœæ­¢æ›´æ–°æ•°æ®
		- (void)stopPedometerUpdates;
		// åœæ­¢çŠ¶æ€æ›´æ–°
		- (void)stopPedometerEventUpdates NS_AVAILABLE(NA,10_0);




 	2. ä¸»è¦çš„ä»£ç å®ç°
     // 1. åˆå§‹åŒ–è®¡æ­¥å™¨self.pedometer
     - (CMPedometer *)pedometer {
            if (!_pedometer) {
                _pedometer = [[CMPedometer alloc] init];
            }
           return _pedometer;
       }

      // 2. é€šè¿‡ä¸€ä¸ªå¼€å…³å¼€å¯ï¼å…³é—­è®°æ­¥åŠŸèƒ½
     - (IBAction)recordStepCount:(UIButton *)sender {
           BOOL start = !sender.selected;
           // å¼€å§‹è®°æ­¥
           if(start){

               // å¯ç”¨æ€§æ£€æµ‹
               if(![CMPedometer isStepCountingAvailable]){
                   [self showWithTitle:@"è®¡æ­¥å™¨ä¸å¯ç”¨" message:nil];
                  return;
               }

               // 1 æˆæƒ
               // 1.1 pedometerç¬¬ä¸€æ¬¡è¢«ä½¿ç”¨æ—¶ï¼Œä¼šç”±ç³»ç»Ÿä¸»åŠ¨æç¤ºç”¨æˆ·æˆæƒâ€œè¿åŠ¨ä¸å¥åº·â€;ä½†æ²¡æ‰¾åˆ°æˆæƒçš„ç›¸å…³æ–¹æ³•ï¼Œé€šè¿‡è¯¥æ–¹å¼å®ç°éœ€æ±‚
               __weak typeof (self) weakSelf = self;
               [self.pedometer queryPedometerDataFromDate:[NSDate date] toDate:[NSDate date] withHandler:^(CMPedometerData * _Nullable pedometerData, NSError * _Nullable error) {
                   // 1.2 ç”¨æˆ·é€‰æ‹©äº†æˆæƒä¸å¦ä¹‹åï¼Œè¯¥blockæ‰ä¼šè¢«è°ƒç”¨ï¼Œä¸åœ¨ä¸»çº¿ç¨‹
                   dispatch_async(dispatch_get_main_queue(), ^{
                       // 1.3 æˆæƒåˆ¤æ–­
                       if(![CMSensorRecorder isAuthorizedForRecording]){
                           [weakSelf showWithTitle:@"æœªæˆæƒ" message:@"å‰å¾€è®¾ç½®ï¼>éšç§->è¿åŠ¨ä¸å¥åº·ï¼Œç‚¹å‡»å…è®¸è®¿é—®"];
                           return;
                       }
                       sender.selected = YES;
                   
                       // 2. è·å–æ•°æ®
                       // 2.1 ç›‘æµ‹è®¡æ­¥å™¨çŠ¶æ€ï¼šæš‚åœã€æ¢å¤
                       [weakSelf.pedometer startPedometerEventUpdatesWithHandler:^(CMPedometerEvent * _Nullable pedometerEvent, NSError * _Nullable error) {
                           NSLog(@"%@",pedometerEvent.type==CMPedometerEventTypePause? @"æš‚åœ":@"ç»§ç»­");
                       }];
                   
                       // 2.2 ç›‘æµ‹è®¡æ­¥å™¨æ•°æ®
                       [weakSelf.pedometer startPedometerUpdatesFromDate:[NSDate date] withHandler:^(CMPedometerData * _Nullable pedometerData, NSError * _Nullable error) {
                           if (pedometerData) {
                               // 2.3 å¤„ç†æ•°æ®ï¼šå›è°ƒä¸åœ¨ä¸»çº¿ç¨‹ï¼Œæ‰€ä»¥éœ€è¦å›åˆ°ä¸»çº¿ç¨‹å¤„ç†
                               dispatch_async(dispatch_get_main_queue(), ^{
                                   // æ•°æ®å­˜å‚¨åœ¨pedometerDataä¸­
                                   ...
                               });
                           }
                       }];
                   });
               }];
           } else {
               // ç»“æŸè®°æ­¥
               sender.selected = NO;
               [self.pedometer stopPedometerUpdates];
               [self.pedometer stopPedometerEventUpdates];
           }
       }

13, åŠ é€Ÿè®¡-é™€èºä»ª-ç£åŠ›è®¡
	// å­˜å‚¨åŠ é€Ÿè®¡æ•°æ®
	@property(readonly, nullable) CMAccelerometerData *accelerometerData;
	// å¼€å§‹æ›´æ–°åŠ é€Ÿè®¡æ•°æ®ï¼Œä¸å¸¦å›è°ƒï¼Œå¯ä»¥æ·»åŠ å®šæ—¶å™¨å®šæ—¶å»è·å–CMMotionManagerå¯¹è±¡çš„accelerometerDataæ•°æ®
	- (void)startAccelerometerUpdates;	
	// å¼€å§‹æ›´æ–°åŠ é€Ÿè®¡æ•°æ®ï¼Œå¸¦å›è°ƒï¼Œç”±äºæ•°æ®å¯èƒ½æ›´æ–°é¢‘ç‡å¿«ï¼Œä¸å»ºè®®ä½¿ç”¨ä¸»é˜Ÿåˆ—
	- (void)startAccelerometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAccelerometerHandler)handler;	
	// ä¸å†éœ€è¦æ›´æ–°æ•°æ®çš„æ—¶å€™éœ€è¦è°ƒç”¨åœæ­¢æ›´æ–°çš„æ–¹æ³•
	- (void)stopAccelerometerUpdates;
	// 1. åˆå§‹åŒ–CMMotionManagerå¯¹è±¡å¹¶è®¾ç½®å±æ€§å­˜å‚¨ï¼Œè®¾ç½®æ•°æ®çš„æ›´æ–°é—´éš”
	   - (CMMotionManager *)motionManage {
		if (!_motionManage) {
			_motionManage = [[CMMotionManager alloc] init];
			// æ§åˆ¶ä¼ æ„Ÿå™¨çš„æ›´æ–°é—´éš”
			_motionManage.accelerometerUpdateInterval = 0.2;
			_motionManage.gyroUpdateInterval = 0.2;
			_motionManage.magnetometerUpdateInterval = 0.2;
		}
		return _motionManage;
	}
	// 2. å¼€å§‹/ç»“æŸæ›´æ–°æ•°æ®ï¼Œåªä¸¾ä¾‹å¸¦å›è°ƒçš„æ–¹æ³•
	- (IBAction)accelerometerTest:(UIButton *)sender {
	    BOOL start = !sender.selected;

	    // 2.1 æ ¹æ®è®¾ç½®çš„æ—¶é—´é—´éš”å®šæœŸæ›´æ–°æ•°æ®
	    if (start) {
	        // å¯ç”¨æ€§æ£€æµ‹
	        if(![self.motionManage isAccelerometerAvailable]){
	            [self showWithTitle:@"åŠ é€Ÿè®¡ä¸å¯ç”¨" message:nil];
	            return;
	        }
	        sender.selected = YES;
	        __weak typeof (self) weakSelf = self;

	        // æ•°æ®æ›´æ–°æœ‰å¯èƒ½æ¯”è¾ƒé¢‘ç¹ï¼Œä¸å»ºè®®ä½¿ç”¨ä¸»é˜Ÿåˆ—
	        NSOperationQueue *queue = [NSOperationQueue new];
	        [self.motionManage startAccelerometerUpdatesToQueue:queue withHandler:^(CMAccelerometerData * _Nullable accelerometerData, NSError * _Nullable error) {
	            // å›åˆ°ä¸»çº¿ç¨‹
	            dispatch_async(dispatch_get_main_queue(), ^{
	                // æ•°æ®æ˜¾ç¤º
	                weakSelf.accelerationXLbl.text = [NSString stringWithFormat:@"%.2f", accelerometerData.acceleration.x];
	                weakSelf.accelerationYLbl.text = [NSString stringWithFormat:@"%.2f", accelerometerData.acceleration.y];
	                weakSelf.accelerationZLbl.text = [NSString stringWithFormat:@"%.2f", accelerometerData.acceleration.z];
	            });
	        }];
	    } else {

	    // 2.2 åœæ­¢è·å–æ•°æ®
	        sender.selected = NO;
	        [self.motionManage stopAccelerometerUpdates];
	    }
	}

14,iOSå®šä½ã€è·å–æ–¹å‘ã€åŒºåŸŸç›‘æµ‹
	åœ¨ info.plist æ·»åŠ æƒé™
	NSLocationWhenInUseUsageDescription  Yes
	NSLocationAlwaysUsageDescription 	Yes


	import CoreLocation
	/// å£°æ˜ä¸€ä¸ªå…¨å±€å˜é‡
	var locationManager:CLLocationManager!
	///å®ç°è°ƒç”¨æ–¹æ³•
	func loacation() {
	    locationManager = CLLocationManager()
	    /// è®¾ç½®å®šä½çš„ç²¾ç¡®åº¦
	    locationManager.desiredAccuracy = kCLLocationAccuracyBest
	    /// è®¾ç½®å®šä½å˜åŒ–çš„æœ€å°è·ç¦» è·ç¦»è¿‡æ»¤å™¨
	    locationManager.distanceFilter = 50
	    /// è®¾ç½®è¯·æ±‚å®šä½çš„çŠ¶æ€
	    if #available(iOS 8.0, *) {
	        /// ç”¨æˆ·ä½¿ç”¨æœŸé—´
	        locationManager.requestWhenInUseAuthorization()
	        /// æ€»æ˜¯å…è®¸
	        locationManager.requestAlwaysAuthorization()
	    }
	    /// è®¾ç½®ä»£ç†
	    locationManager.delegate = self;
	    if CLLocationManager.locationServicesEnabled(){
	        /// å¼€å¯å®šä½æœåŠ¡
	        locationManager.startUpdatingLocation()
	        /// å¼€å¯æ–¹å‘æœåŠ¡
	        locationManager.startUpdatingHeading()
	        /// å…ˆæŒ‡å®šä½ç½®ä¸­å¿ƒ
	        var companyCenter = CLLocationCoordinate2D()
	        companyCenter.latitude = 29.61710109843841
	        companyCenter.longitude = 106.49967413405561
	        /// è®¾ç½®ä¸€ä¸ªæ–¹åœ†200ç±³çš„èŒƒå›´
	        let regin = CLCircularRegion.init(center: companyCenter, radius: 200, identifier: "id")
	        /// å¼€å§‹ç›‘å¬æœ‰æ²¡æœ‰è¿›å…¥ã€ç¦»å¼€è¿™ä¸ªåŒºåŸŸ
	        locationManager.startMonitoring(for: regin)
	    } else {
	        print("æ²¡æœ‰å®šä½æœåŠ¡")
	    }
	}

	///å®ç°ä»£ç†æ–¹æ³•
	extension ViewController: CLLocationManagerDelegate {
	    /// å®šä½å¤±è´¥è°ƒç”¨çš„ä»£ç†æ–¹æ³•
	    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
	        print(error.localizedDescription)
	    }
	    
	    /// å½“å®šä½æˆæƒçŠ¶æ€æ”¹å˜
	    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
	        switch status {
	            case .notDetermined:
	                print("æœªå†³å®š")
	            case .restricted:
	                print("æœªæˆæƒ")
	            case .denied:
	                print("æ‹’ç»")
	            case .authorizedAlways:
	                print("æ€»æ˜¯å…è®¸")
	            case .authorizedWhenInUse:
	                print("ä»…ä½¿ç”¨æ—¶")
	            @unknown default:
	                print("")
	        }
	    }

	    /// å®šä½æ›´æ–°åœ°ç†ä¿¡æ¯è°ƒç”¨çš„ä»£ç†æ–¹æ³•
	    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
	        /// åœæ­¢å®šä½
	        manager.stopUpdatingLocation()
	        /// è·å–ç”¨æˆ·ä½ç½®çš„å¯¹è±¡
	        if locations.count > 0, let info = locations.last {
	            print("æµ·æ‹”ï¼š\(info.altitude),ç»åº¦ï¼š\(info.coordinate.longitude), çº¬åº¦ï¼š\(info.coordinate.latitude)")
	            let coder = CLGeocoder()
	            coder.reverseGeocodeLocation(info) { marks, error in
	                if let list = marks, list.count > 0{
	                    let placemark = list[0]
	                    print("å›½å®¶ï¼š\(placemark.country!) åŸå¸‚ï¼š\(placemark.locality!) åŒºå¿ï¼š\(placemark.subLocality!) è¡—é“ï¼š\(placemark.thoroughfare!)")
	                }
	            }
	            
	        }

	     }
	     
	    /// è·å–è®¾å¤‡çš„æœå‘
	    func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
	        print("X:\(newHeading.x),Y:\(newHeading.y),Z:\(newHeading.z),")
	        
	    }
	    
	        /// è¿›å…¥æŒ‡å®šåŒºåŸŸ
	    func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {
	        let alertController = UIAlertController(title: "æç¤º", message: "è¿›å…¥è€ƒæ ¸åŒºåŸŸ", preferredStyle: .alert)
	        let action = UIAlertAction(title: "ç¡®å®š", style: .cancel, handler: nil)
	        alertController.addAction(action)
	        self.present(alertController, animated: true, completion: nil)
	    }
	    
	    /// ç¦»å¼€æŒ‡å®šåŒºåŸŸ
	    func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {
	        let alertController = UIAlertController(title: "æç¤º", message: "ç¦»å¼€è€ƒæ ¸åŒºåŸŸ", preferredStyle: .alert)
	        let action = UIAlertAction(title: "ç¡®å®š", style: .cancel, handler: nil)
	        alertController.addAction(action)
	        self.present(alertController, animated: true, completion: nil)
	    }
	}

15,è‡ªå¸¦ç¿»è¯‘APIè°ƒç”¨åŠä»£ç å®ç°
	<1>,åœ¨â€œGeneralâ€é€‰é¡¹å¡ä¸‹æ‰¾åˆ°â€œLinked Frameworks and Librariesâ€å’Œâ€œEmbedded Binariesâ€ï¼Œç„¶åå•å‡»â€œ+â€æŒ‰é’®ã€‚
	<2>, è¯­éŸ³ï¼šä»å¼¹å‡ºèœå•ä¸­é€‰æ‹©â€œSpeech.frameworkâ€
	<3>, å¦‚æœæ‚¨æƒ³ä½¿ç”¨ç¿»è¯‘æœºå™¨æ¡†æ¶ï¼Œè¯·ç»§ç»­å•å‡»â€œ+â€æŒ‰é’®å¹¶å¯¼å…¥â€œTranslation.frameworkâ€
	ã€Š4ã€‹ï¼Œæ·»åŠ è®¿é—®æƒé™
		

		import Foundation
		import Speech

		class TranslationService {
		  private let speechRecognizer = SFSpeechRecognizer(locale: Locale(identifier: "zh-CN"))
		  
		  func translate(text: String, completion: @escaping (Result<String, Error>) -> Void) {
		    let request = SFSpeechTranslationRequest(locale: Locale(identifier: "en"))
		    request.sourceSpeech = AVSpeechUtterance(string: text)
		    
		    speechRecognizer?.recognitionTask(with: request) { (result, error) in
		      guard let translationResult = result else {
		        completion(.failure(error!))
		        return
		      }
		      
		      completion(.success(translationResult.translations.first?.formattedString ?? ""))
		    }
		  }
		}


		//å¼•å…¥å¤´æ–‡ä»¶
		import Speech

		// è¯·æ±‚è¯­éŸ³è¯†åˆ«æˆæƒ
		SFSpeechRecognizer.requestAuthorization { authStatus in
		    if authStatus == .authorized {
		        print("æˆæƒæˆåŠŸ")
		    }
		}

		// åˆ›å»ºSpeechRecognizerå¯¹è±¡ï¼Œç”¨äºè¯†åˆ«è¯­éŸ³
		let recognizer = SFSpeechRecognizer(locale: Locale(identifier: "zh-CN"))
		// åˆ›å»ºè¯†åˆ«è¯·æ±‚ ï¼‰
		let request = SFSpeechURLRecognitionRequest(url: audioFileURL)
		// å¼€å§‹è¯†åˆ«è¯­éŸ³
		recognizer?.recognitionTask(with: request, resultHandler: { (result, error) in
		    if let result = result {
		        // è·å–è¯­éŸ³è¯†åˆ«ç»“æœ
		        let transcript = result.bestTranscription.formattedString

		        // åˆ›å»ºç¿»è¯‘è¯·æ±‚
		        let options: [String: Any] = [
		            "sourceLanguage": "en",
		            "targetLanguage": "zh-CN"
		        ]
		        let request = NSLinguisticTagger.Request(tagSchemes: [.languageTranslation], options: options)

		        // è¿›è¡Œç¿»è¯‘
		        NSLinguisticTagger(tagSchemes: [.languageTranslation], options: Int(), schemes: nil).string = transcript
		        let translation = try? NSLinguisticTagger(tagSchemes: [.languageTranslation], options: Int(), schemes: [NSLinguisticTagScheme.languageTranslation.rawValue]).linguisticTags(in: NSRange(location: 0, length: transcript.count), scheme: .languageTranslation, options: options, tokenRanges: nil).first

		        print("è¯†åˆ«ç»“æœï¼š\(transcript)")
		        print("ç¿»è¯‘ç»“æœï¼š\(translation ?? "")")
		    } else if let error = error {
		        print(error.localizedDescription)
		    }
		})


		// åˆ›å»ºä¸€ä¸ªç¿»è¯‘å™¨å®ä¾‹
		let translator = Translator()
		// è®¾ç½®è¦ç¿»è¯‘çš„æºè¯­è¨€å’Œç›®æ ‡è¯­è¨€
		translator.sourceLanguage = .english
		translator.targetLanguage = .chinese
		// è®¾ç½®è¦ç¿»è¯‘çš„æ–‡æœ¬
		let textToTranslate = "Hello World"
		// æ‰§è¡Œç¿»è¯‘
		let translatedText = translator.translate(textToTranslate)
		// è¾“å‡ºç¿»è¯‘åçš„æ–‡æœ¬
		print("Translated Text: \(translatedText)")

16ï¼Œocåœ°å›¾è®¿é—®
	å¼•å…¥åº“ï¼šMapKit.framework
	å¯¼å…¥å¤´æ–‡ä»¶ï¼š
		#import <CoreLocation/CoreLocation.h>
		#import <MapKit/MapKit.h>
	ã€åœ°ç‚¹æ ‡æ³¨ã€‘
		MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation];
		MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:CLLocationCoordinate2DMake(self.lat.floatValue, self.lon.floatValue) addressDictionary:nil]]; //ç›®çš„åœ°åæ ‡
		toLocation.name = self.destination; //ç›®çš„åœ°åå­—
		[toLocation openInMapsWithLaunchOptions:nil];
	ã€çº¿è·¯å¯¼èˆªã€‘
		MKMapItem *currentLocation = [MKMapItem mapItemForCurrentLocation];
		MKMapItem *toLocation = [[MKMapItem alloc] initWithPlacemark:[[MKPlacemark alloc] initWithCoordinate:CLLocationCoordinate2DMake(self.lat.floatValue, self.lon.floatValue) addressDictionary:nil]]; //ç›®çš„åœ°åæ ‡
		    toLocation.name = self.destination; //ç›®çš„åœ°åå­—
		[MKMapItem openMapsWithItems:@[currentLocation, toLocation] launchOptions:@{MKLaunchOptionsDirectionsModeKey: MKLaunchOptionsDirectionsModeWalking,MKLaunchOptionsShowsTrafficKey: [NSNumber numberWithBool:NO]}];
		/**
         MKLaunchOptionsDirectionsModeKey   è·¯çº¿æ¨¡å¼ï¼Œå¸¸é‡
         MKLaunchOptionsDirectionsModeDriving  é©¾è½¦æ¨¡å¼
         MKLaunchOptionsDirectionsModeWalking æ­¥è¡Œæ¨¡å¼
         
         MKLaunchOptionsMapTypeKey  åœ°å›¾ç±»å‹ï¼Œ
         æšä¸¾ MKMapTypeStandard ï¼šæ ‡å‡†æ¨¡å¼
         MKMapTypeSatellite ï¼šå«æ˜Ÿæ¨¡å¼
         MKMapTypeHybrid  ï¼šæ··åˆæ¨¡å¼
         
         MKLaunchOptionsMapCenterKey ä¸­å¿ƒç‚¹åæ ‡ï¼Œ CLLocationCoordinate2Dç±»å‹
         MKLaunchOptionsMapSpanKey  åœ°å›¾æ˜¾ç¤ºè·¨åº¦ï¼ŒMKCoordinateSpan ç±»å‹
         MKLaunchOptionsShowsTrafficKey æ˜¯å¦ æ˜¾ç¤ºäº¤é€šçŠ¶å†µï¼Œå¸ƒå°”å‹
         MKLaunchOptionsCameraKey   3Dåœ°å›¾æ•ˆæœï¼ŒMKMapCameraç±»å‹(æ³¨æ„ï¼šæ­¤å±æ€§ä»iOS7åŠä»¥åå¯ç”¨ï¼Œå‰é¢çš„å±æ€§ä»iOS6å¼€å§‹å¯ç”¨)
         */

17ï¼ŒiOS æƒé™éƒ¨åˆ†
	<key>NSSpeechRecognitionUsageDescription</key>
	<string>æ‚¨çš„åº”ç”¨éœ€è¦è®¿é—®è¯­éŸ³è¯†åˆ«ä»¥ä¾¿è¿›è¡Œç¿»è¯‘ã€‚</string>
	<key>NSMicrophoneUsageDescription</key>
	<string>æ‚¨çš„åº”ç”¨éœ€è¦è®¿é—®éº¦å…‹é£ä»¥ä¾¿è¿›è¡Œè¯­éŸ³è¾“å…¥ã€‚</string>

	<key>NSCameraUsageDescription</key>
	<string>å¼€å¯ç›¸æœºæƒé™ï¼Œæ´»åŠ¨æ‰«ä¸€æ‰«æ›´å¿«æ·</string>
	<key>NSLocationAlwaysAndwhenInUseUsageDescription</key>
	<string>å¼€å¯å®šä½æƒé™</string>
	<key>NSLocationAlwaysUsageDescription</key>
	<string>å¼€å¯å®šä½æƒé™</string>
	<key>NSLocationwhenInUseUsageDescription</key>
	<string>å¼€å¯å®šä½æƒé™</string>
	<key>NsMicrophoneUsageDescription</key>
	<string>å¼€å¯éº¦å…‹é£æƒé™</string>
	<key>NsPhotoLibraryAddUsageDescription</key>
	<string>æ·»åŠ ç…§ç‰‡éœ€è¦æ‚¨çš„åŒæ„</string>
	<key>NsphotoLibraryUsageDescription</key>
	<string>å¼€å¯ç…§ç‰‡æƒé™</string>

	<!-- è“ç‰™ -->   
	<key>NSBluetoothPeripheralUsageDescription</key>   
	<string>Appéœ€è¦æ‚¨çš„åŒæ„,æ‰èƒ½è®¿é—®è“ç‰™</string>  
	<!-- åœ°å›¾ -->
	LSApplicationQueriesSchemes
		iosamap
		baidumap
		qqmap